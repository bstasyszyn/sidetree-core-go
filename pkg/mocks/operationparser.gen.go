// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	batchapi "github.com/trustbloc/sidetree-core-go/pkg/api/batch"
	"github.com/trustbloc/sidetree-core-go/pkg/api/protocol"
	"github.com/trustbloc/sidetree-core-go/pkg/restapi/model"
)

type OperationParser struct {
	ParseStub        func(namespace string, operationBuffer []byte) (*batchapi.Operation, error)
	parseMutex       sync.RWMutex
	parseArgsForCall []struct {
		namespace       string
		operationBuffer []byte
	}
	parseReturns struct {
		result1 *batchapi.Operation
		result2 error
	}
	parseReturnsOnCall map[int]struct {
		result1 *batchapi.Operation
		result2 error
	}
	ParseCreateStub        func(request []byte) (*batchapi.Operation, error)
	parseCreateMutex       sync.RWMutex
	parseCreateArgsForCall []struct {
		request []byte
	}
	parseCreateReturns struct {
		result1 *batchapi.Operation
		result2 error
	}
	parseCreateReturnsOnCall map[int]struct {
		result1 *batchapi.Operation
		result2 error
	}
	ParseSuffixDataStub        func(encoded string) (*model.SuffixDataModel, error)
	parseSuffixDataMutex       sync.RWMutex
	parseSuffixDataArgsForCall []struct {
		encoded string
	}
	parseSuffixDataReturns struct {
		result1 *model.SuffixDataModel
		result2 error
	}
	parseSuffixDataReturnsOnCall map[int]struct {
		result1 *model.SuffixDataModel
		result2 error
	}
	ParseDeltaStub        func(encoded string) (*model.DeltaModel, error)
	parseDeltaMutex       sync.RWMutex
	parseDeltaArgsForCall []struct {
		encoded string
	}
	parseDeltaReturns struct {
		result1 *model.DeltaModel
		result2 error
	}
	parseDeltaReturnsOnCall map[int]struct {
		result1 *model.DeltaModel
		result2 error
	}
	ParseSignedDataForUpdateStub        func(compactJWS string) (*model.UpdateSignedDataModel, error)
	parseSignedDataForUpdateMutex       sync.RWMutex
	parseSignedDataForUpdateArgsForCall []struct {
		compactJWS string
	}
	parseSignedDataForUpdateReturns struct {
		result1 *model.UpdateSignedDataModel
		result2 error
	}
	parseSignedDataForUpdateReturnsOnCall map[int]struct {
		result1 *model.UpdateSignedDataModel
		result2 error
	}
	ParseSignedDataForDeactivateStub        func(compactJWS string) (*model.DeactivateSignedDataModel, error)
	parseSignedDataForDeactivateMutex       sync.RWMutex
	parseSignedDataForDeactivateArgsForCall []struct {
		compactJWS string
	}
	parseSignedDataForDeactivateReturns struct {
		result1 *model.DeactivateSignedDataModel
		result2 error
	}
	parseSignedDataForDeactivateReturnsOnCall map[int]struct {
		result1 *model.DeactivateSignedDataModel
		result2 error
	}
	ParseSignedDataForRecoverStub        func(compactJWS string) (*model.RecoverSignedDataModel, error)
	parseSignedDataForRecoverMutex       sync.RWMutex
	parseSignedDataForRecoverArgsForCall []struct {
		compactJWS string
	}
	parseSignedDataForRecoverReturns struct {
		result1 *model.RecoverSignedDataModel
		result2 error
	}
	parseSignedDataForRecoverReturnsOnCall map[int]struct {
		result1 *model.RecoverSignedDataModel
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *OperationParser) Parse(namespace string, operationBuffer []byte) (*batchapi.Operation, error) {
	var operationBufferCopy []byte
	if operationBuffer != nil {
		operationBufferCopy = make([]byte, len(operationBuffer))
		copy(operationBufferCopy, operationBuffer)
	}
	fake.parseMutex.Lock()
	ret, specificReturn := fake.parseReturnsOnCall[len(fake.parseArgsForCall)]
	fake.parseArgsForCall = append(fake.parseArgsForCall, struct {
		namespace       string
		operationBuffer []byte
	}{namespace, operationBufferCopy})
	fake.recordInvocation("Parse", []interface{}{namespace, operationBufferCopy})
	fake.parseMutex.Unlock()
	if fake.ParseStub != nil {
		return fake.ParseStub(namespace, operationBuffer)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseReturns.result1, fake.parseReturns.result2
}

func (fake *OperationParser) ParseCallCount() int {
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	return len(fake.parseArgsForCall)
}

func (fake *OperationParser) ParseArgsForCall(i int) (string, []byte) {
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	return fake.parseArgsForCall[i].namespace, fake.parseArgsForCall[i].operationBuffer
}

func (fake *OperationParser) ParseReturns(result1 *batchapi.Operation, result2 error) {
	fake.ParseStub = nil
	fake.parseReturns = struct {
		result1 *batchapi.Operation
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseReturnsOnCall(i int, result1 *batchapi.Operation, result2 error) {
	fake.ParseStub = nil
	if fake.parseReturnsOnCall == nil {
		fake.parseReturnsOnCall = make(map[int]struct {
			result1 *batchapi.Operation
			result2 error
		})
	}
	fake.parseReturnsOnCall[i] = struct {
		result1 *batchapi.Operation
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseCreate(request []byte) (*batchapi.Operation, error) {
	var requestCopy []byte
	if request != nil {
		requestCopy = make([]byte, len(request))
		copy(requestCopy, request)
	}
	fake.parseCreateMutex.Lock()
	ret, specificReturn := fake.parseCreateReturnsOnCall[len(fake.parseCreateArgsForCall)]
	fake.parseCreateArgsForCall = append(fake.parseCreateArgsForCall, struct {
		request []byte
	}{requestCopy})
	fake.recordInvocation("ParseCreate", []interface{}{requestCopy})
	fake.parseCreateMutex.Unlock()
	if fake.ParseCreateStub != nil {
		return fake.ParseCreateStub(request)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseCreateReturns.result1, fake.parseCreateReturns.result2
}

func (fake *OperationParser) ParseCreateCallCount() int {
	fake.parseCreateMutex.RLock()
	defer fake.parseCreateMutex.RUnlock()
	return len(fake.parseCreateArgsForCall)
}

func (fake *OperationParser) ParseCreateArgsForCall(i int) []byte {
	fake.parseCreateMutex.RLock()
	defer fake.parseCreateMutex.RUnlock()
	return fake.parseCreateArgsForCall[i].request
}

func (fake *OperationParser) ParseCreateReturns(result1 *batchapi.Operation, result2 error) {
	fake.ParseCreateStub = nil
	fake.parseCreateReturns = struct {
		result1 *batchapi.Operation
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseCreateReturnsOnCall(i int, result1 *batchapi.Operation, result2 error) {
	fake.ParseCreateStub = nil
	if fake.parseCreateReturnsOnCall == nil {
		fake.parseCreateReturnsOnCall = make(map[int]struct {
			result1 *batchapi.Operation
			result2 error
		})
	}
	fake.parseCreateReturnsOnCall[i] = struct {
		result1 *batchapi.Operation
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSuffixData(encoded string) (*model.SuffixDataModel, error) {
	fake.parseSuffixDataMutex.Lock()
	ret, specificReturn := fake.parseSuffixDataReturnsOnCall[len(fake.parseSuffixDataArgsForCall)]
	fake.parseSuffixDataArgsForCall = append(fake.parseSuffixDataArgsForCall, struct {
		encoded string
	}{encoded})
	fake.recordInvocation("ParseSuffixData", []interface{}{encoded})
	fake.parseSuffixDataMutex.Unlock()
	if fake.ParseSuffixDataStub != nil {
		return fake.ParseSuffixDataStub(encoded)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseSuffixDataReturns.result1, fake.parseSuffixDataReturns.result2
}

func (fake *OperationParser) ParseSuffixDataCallCount() int {
	fake.parseSuffixDataMutex.RLock()
	defer fake.parseSuffixDataMutex.RUnlock()
	return len(fake.parseSuffixDataArgsForCall)
}

func (fake *OperationParser) ParseSuffixDataArgsForCall(i int) string {
	fake.parseSuffixDataMutex.RLock()
	defer fake.parseSuffixDataMutex.RUnlock()
	return fake.parseSuffixDataArgsForCall[i].encoded
}

func (fake *OperationParser) ParseSuffixDataReturns(result1 *model.SuffixDataModel, result2 error) {
	fake.ParseSuffixDataStub = nil
	fake.parseSuffixDataReturns = struct {
		result1 *model.SuffixDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSuffixDataReturnsOnCall(i int, result1 *model.SuffixDataModel, result2 error) {
	fake.ParseSuffixDataStub = nil
	if fake.parseSuffixDataReturnsOnCall == nil {
		fake.parseSuffixDataReturnsOnCall = make(map[int]struct {
			result1 *model.SuffixDataModel
			result2 error
		})
	}
	fake.parseSuffixDataReturnsOnCall[i] = struct {
		result1 *model.SuffixDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseDelta(encoded string) (*model.DeltaModel, error) {
	fake.parseDeltaMutex.Lock()
	ret, specificReturn := fake.parseDeltaReturnsOnCall[len(fake.parseDeltaArgsForCall)]
	fake.parseDeltaArgsForCall = append(fake.parseDeltaArgsForCall, struct {
		encoded string
	}{encoded})
	fake.recordInvocation("ParseDelta", []interface{}{encoded})
	fake.parseDeltaMutex.Unlock()
	if fake.ParseDeltaStub != nil {
		return fake.ParseDeltaStub(encoded)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseDeltaReturns.result1, fake.parseDeltaReturns.result2
}

func (fake *OperationParser) ParseDeltaCallCount() int {
	fake.parseDeltaMutex.RLock()
	defer fake.parseDeltaMutex.RUnlock()
	return len(fake.parseDeltaArgsForCall)
}

func (fake *OperationParser) ParseDeltaArgsForCall(i int) string {
	fake.parseDeltaMutex.RLock()
	defer fake.parseDeltaMutex.RUnlock()
	return fake.parseDeltaArgsForCall[i].encoded
}

func (fake *OperationParser) ParseDeltaReturns(result1 *model.DeltaModel, result2 error) {
	fake.ParseDeltaStub = nil
	fake.parseDeltaReturns = struct {
		result1 *model.DeltaModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseDeltaReturnsOnCall(i int, result1 *model.DeltaModel, result2 error) {
	fake.ParseDeltaStub = nil
	if fake.parseDeltaReturnsOnCall == nil {
		fake.parseDeltaReturnsOnCall = make(map[int]struct {
			result1 *model.DeltaModel
			result2 error
		})
	}
	fake.parseDeltaReturnsOnCall[i] = struct {
		result1 *model.DeltaModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForUpdate(compactJWS string) (*model.UpdateSignedDataModel, error) {
	fake.parseSignedDataForUpdateMutex.Lock()
	ret, specificReturn := fake.parseSignedDataForUpdateReturnsOnCall[len(fake.parseSignedDataForUpdateArgsForCall)]
	fake.parseSignedDataForUpdateArgsForCall = append(fake.parseSignedDataForUpdateArgsForCall, struct {
		compactJWS string
	}{compactJWS})
	fake.recordInvocation("ParseSignedDataForUpdate", []interface{}{compactJWS})
	fake.parseSignedDataForUpdateMutex.Unlock()
	if fake.ParseSignedDataForUpdateStub != nil {
		return fake.ParseSignedDataForUpdateStub(compactJWS)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseSignedDataForUpdateReturns.result1, fake.parseSignedDataForUpdateReturns.result2
}

func (fake *OperationParser) ParseSignedDataForUpdateCallCount() int {
	fake.parseSignedDataForUpdateMutex.RLock()
	defer fake.parseSignedDataForUpdateMutex.RUnlock()
	return len(fake.parseSignedDataForUpdateArgsForCall)
}

func (fake *OperationParser) ParseSignedDataForUpdateArgsForCall(i int) string {
	fake.parseSignedDataForUpdateMutex.RLock()
	defer fake.parseSignedDataForUpdateMutex.RUnlock()
	return fake.parseSignedDataForUpdateArgsForCall[i].compactJWS
}

func (fake *OperationParser) ParseSignedDataForUpdateReturns(result1 *model.UpdateSignedDataModel, result2 error) {
	fake.ParseSignedDataForUpdateStub = nil
	fake.parseSignedDataForUpdateReturns = struct {
		result1 *model.UpdateSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForUpdateReturnsOnCall(i int, result1 *model.UpdateSignedDataModel, result2 error) {
	fake.ParseSignedDataForUpdateStub = nil
	if fake.parseSignedDataForUpdateReturnsOnCall == nil {
		fake.parseSignedDataForUpdateReturnsOnCall = make(map[int]struct {
			result1 *model.UpdateSignedDataModel
			result2 error
		})
	}
	fake.parseSignedDataForUpdateReturnsOnCall[i] = struct {
		result1 *model.UpdateSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForDeactivate(compactJWS string) (*model.DeactivateSignedDataModel, error) {
	fake.parseSignedDataForDeactivateMutex.Lock()
	ret, specificReturn := fake.parseSignedDataForDeactivateReturnsOnCall[len(fake.parseSignedDataForDeactivateArgsForCall)]
	fake.parseSignedDataForDeactivateArgsForCall = append(fake.parseSignedDataForDeactivateArgsForCall, struct {
		compactJWS string
	}{compactJWS})
	fake.recordInvocation("ParseSignedDataForDeactivate", []interface{}{compactJWS})
	fake.parseSignedDataForDeactivateMutex.Unlock()
	if fake.ParseSignedDataForDeactivateStub != nil {
		return fake.ParseSignedDataForDeactivateStub(compactJWS)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseSignedDataForDeactivateReturns.result1, fake.parseSignedDataForDeactivateReturns.result2
}

func (fake *OperationParser) ParseSignedDataForDeactivateCallCount() int {
	fake.parseSignedDataForDeactivateMutex.RLock()
	defer fake.parseSignedDataForDeactivateMutex.RUnlock()
	return len(fake.parseSignedDataForDeactivateArgsForCall)
}

func (fake *OperationParser) ParseSignedDataForDeactivateArgsForCall(i int) string {
	fake.parseSignedDataForDeactivateMutex.RLock()
	defer fake.parseSignedDataForDeactivateMutex.RUnlock()
	return fake.parseSignedDataForDeactivateArgsForCall[i].compactJWS
}

func (fake *OperationParser) ParseSignedDataForDeactivateReturns(result1 *model.DeactivateSignedDataModel, result2 error) {
	fake.ParseSignedDataForDeactivateStub = nil
	fake.parseSignedDataForDeactivateReturns = struct {
		result1 *model.DeactivateSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForDeactivateReturnsOnCall(i int, result1 *model.DeactivateSignedDataModel, result2 error) {
	fake.ParseSignedDataForDeactivateStub = nil
	if fake.parseSignedDataForDeactivateReturnsOnCall == nil {
		fake.parseSignedDataForDeactivateReturnsOnCall = make(map[int]struct {
			result1 *model.DeactivateSignedDataModel
			result2 error
		})
	}
	fake.parseSignedDataForDeactivateReturnsOnCall[i] = struct {
		result1 *model.DeactivateSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForRecover(compactJWS string) (*model.RecoverSignedDataModel, error) {
	fake.parseSignedDataForRecoverMutex.Lock()
	ret, specificReturn := fake.parseSignedDataForRecoverReturnsOnCall[len(fake.parseSignedDataForRecoverArgsForCall)]
	fake.parseSignedDataForRecoverArgsForCall = append(fake.parseSignedDataForRecoverArgsForCall, struct {
		compactJWS string
	}{compactJWS})
	fake.recordInvocation("ParseSignedDataForRecover", []interface{}{compactJWS})
	fake.parseSignedDataForRecoverMutex.Unlock()
	if fake.ParseSignedDataForRecoverStub != nil {
		return fake.ParseSignedDataForRecoverStub(compactJWS)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseSignedDataForRecoverReturns.result1, fake.parseSignedDataForRecoverReturns.result2
}

func (fake *OperationParser) ParseSignedDataForRecoverCallCount() int {
	fake.parseSignedDataForRecoverMutex.RLock()
	defer fake.parseSignedDataForRecoverMutex.RUnlock()
	return len(fake.parseSignedDataForRecoverArgsForCall)
}

func (fake *OperationParser) ParseSignedDataForRecoverArgsForCall(i int) string {
	fake.parseSignedDataForRecoverMutex.RLock()
	defer fake.parseSignedDataForRecoverMutex.RUnlock()
	return fake.parseSignedDataForRecoverArgsForCall[i].compactJWS
}

func (fake *OperationParser) ParseSignedDataForRecoverReturns(result1 *model.RecoverSignedDataModel, result2 error) {
	fake.ParseSignedDataForRecoverStub = nil
	fake.parseSignedDataForRecoverReturns = struct {
		result1 *model.RecoverSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) ParseSignedDataForRecoverReturnsOnCall(i int, result1 *model.RecoverSignedDataModel, result2 error) {
	fake.ParseSignedDataForRecoverStub = nil
	if fake.parseSignedDataForRecoverReturnsOnCall == nil {
		fake.parseSignedDataForRecoverReturnsOnCall = make(map[int]struct {
			result1 *model.RecoverSignedDataModel
			result2 error
		})
	}
	fake.parseSignedDataForRecoverReturnsOnCall[i] = struct {
		result1 *model.RecoverSignedDataModel
		result2 error
	}{result1, result2}
}

func (fake *OperationParser) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	fake.parseCreateMutex.RLock()
	defer fake.parseCreateMutex.RUnlock()
	fake.parseSuffixDataMutex.RLock()
	defer fake.parseSuffixDataMutex.RUnlock()
	fake.parseDeltaMutex.RLock()
	defer fake.parseDeltaMutex.RUnlock()
	fake.parseSignedDataForUpdateMutex.RLock()
	defer fake.parseSignedDataForUpdateMutex.RUnlock()
	fake.parseSignedDataForDeactivateMutex.RLock()
	defer fake.parseSignedDataForDeactivateMutex.RUnlock()
	fake.parseSignedDataForRecoverMutex.RLock()
	defer fake.parseSignedDataForRecoverMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *OperationParser) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ protocol.OperationParser = new(OperationParser)
